<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SphinxBase: include/sphinxbase/hash_table.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SphinxBase
   &#160;<span id="projectnumber">0.6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hash__table_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hash_table.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hash table implementation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sphinxbase/sphinxbase_export.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="prim__type_8h_source.html">sphinxbase/prim_type.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="glist_8h_source.html">sphinxbase/glist.h</a>&gt;</code><br/>
</div>
<p><a href="hash__table_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__entry__s.html">hash_entry_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing.  <a href="structhash__entry__s.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__table__t.html">hash_table_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhash__iter__s.html">hash_iter_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac98525ff8ec582358783aecbd388842d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac98525ff8ec582358783aecbd388842d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ac98525ff8ec582358783aecbd388842d">hash_entry_val</a>(e)&#160;&#160;&#160;((e)-&gt;val)</td></tr>
<tr class="memdesc:ac98525ff8ec582358783aecbd388842d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access macros. <br/></td></tr>
<tr class="separator:ac98525ff8ec582358783aecbd388842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff378b212469b2ec6dde13b6f0934b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ff378b212469b2ec6dde13b6f0934b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_entry_key</b>(e)&#160;&#160;&#160;((e)-&gt;key)</td></tr>
<tr class="separator:aa9ff378b212469b2ec6dde13b6f0934b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0d92dd662edb83d572dc2fef278816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c0d92dd662edb83d572dc2fef278816"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_entry_len</b>(e)&#160;&#160;&#160;((e)-&gt;len)</td></tr>
<tr class="separator:a4c0d92dd662edb83d572dc2fef278816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47264dff359c0a0d4c144e54d0819ce9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47264dff359c0a0d4c144e54d0819ce9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_inuse</b>(h)&#160;&#160;&#160;((h)-&gt;inuse)</td></tr>
<tr class="separator:a47264dff359c0a0d4c144e54d0819ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d9d0efddc207e3d7be3c417dcd7128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0d9d0efddc207e3d7be3c417dcd7128"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table_size</b>(h)&#160;&#160;&#160;((h)-&gt;size)</td></tr>
<tr class="separator:aa0d9d0efddc207e3d7be3c417dcd7128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbbcfa2a2d360c2a8960b960ae34a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30fbbcfa2a2d360c2a8960b960ae34a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_YES</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a30fbbcfa2a2d360c2a8960b960ae34a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1a9795611575f717b08d2bad5d6f83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1a9795611575f717b08d2bad5d6f83"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>HASH_CASE_NO</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:aec1a9795611575f717b08d2bad5d6f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393c56322e54607a48e6bc61169d92bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a393c56322e54607a48e6bc61169d92bf">hash_table_enter_int32</a>(h, k, v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a>((h),(k),(void *)(long)(v)))</td></tr>
<tr class="memdesc:a393c56322e54607a48e6bc61169d92bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a 32-bit integer value to a hash table.  <a href="#a393c56322e54607a48e6bc61169d92bf">More...</a><br/></td></tr>
<tr class="separator:a393c56322e54607a48e6bc61169d92bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4286033aa772a9d1f3aa219469324f5b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a4286033aa772a9d1f3aa219469324f5b">hash_table_replace_int32</a>(h, k, v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a>((h),(k),(void *)(long)(v)))</td></tr>
<tr class="memdesc:a4286033aa772a9d1f3aa219469324f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a 32-bit integer value in a hash table.  <a href="#a4286033aa772a9d1f3aa219469324f5b">More...</a><br/></td></tr>
<tr class="separator:a4286033aa772a9d1f3aa219469324f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada31c1e0bcf359a7ca934748f4680333"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ada31c1e0bcf359a7ca934748f4680333">hash_table_enter_bkey_int32</a>(h, k, l, v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a>((h),(k),(l),(void *)(long)(v)))</td></tr>
<tr class="memdesc:ada31c1e0bcf359a7ca934748f4680333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter a 32-bit integer value in a hash table.  <a href="#ada31c1e0bcf359a7ca934748f4680333">More...</a><br/></td></tr>
<tr class="separator:ada31c1e0bcf359a7ca934748f4680333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace238b264acacb8e6cb0de14f1035f53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ace238b264acacb8e6cb0de14f1035f53">hash_table_replace_bkey_int32</a>(h, k, l, v)&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a>((h),(k),(l),(void *)(long)(v)))</td></tr>
<tr class="memdesc:ace238b264acacb8e6cb0de14f1035f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a 32-bit integer value in a hash table.  <a href="#ace238b264acacb8e6cb0de14f1035f53">More...</a><br/></td></tr>
<tr class="separator:ace238b264acacb8e6cb0de14f1035f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af70e2b25a853da786ffd99731a5fac5a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#af70e2b25a853da786ffd99731a5fac5a">hash_entry_t</a></td></tr>
<tr class="memdesc:af70e2b25a853da786ffd99731a5fac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing.  <a href="#af70e2b25a853da786ffd99731a5fac5a">More...</a><br/></td></tr>
<tr class="separator:af70e2b25a853da786ffd99731a5fac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8febad57d856465fb33dd11cabc57dcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8febad57d856465fb33dd11cabc57dcc"></a>
typedef struct <a class="el" href="structhash__iter__s.html">hash_iter_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hash_iter_t</b></td></tr>
<tr class="separator:a8febad57d856465fb33dd11cabc57dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a56d93e8c03e066b77377ac6eab50cfae"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a56d93e8c03e066b77377ac6eab50cfae">hash_table_new</a> (int32 size, int32 casearg)</td></tr>
<tr class="memdesc:a56d93e8c03e066b77377ac6eab50cfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new hash table for a given expected size.  <a href="#a56d93e8c03e066b77377ac6eab50cfae">More...</a><br/></td></tr>
<tr class="separator:a56d93e8c03e066b77377ac6eab50cfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a588c22946f8cc16328973035ed19e3"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a0a588c22946f8cc16328973035ed19e3">hash_table_free</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h)</td></tr>
<tr class="memdesc:a0a588c22946f8cc16328973035ed19e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries.  <a href="#a0a588c22946f8cc16328973035ed19e3">More...</a><br/></td></tr>
<tr class="separator:a0a588c22946f8cc16328973035ed19e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfe63c3869c271b125a8413ee384412"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, void *val)</td></tr>
<tr class="memdesc:aebfe63c3869c271b125a8413ee384412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to add a new entry with given key and associated value to hash table h.  <a href="#aebfe63c3869c271b125a8413ee384412">More...</a><br/></td></tr>
<tr class="separator:aebfe63c3869c271b125a8413ee384412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b28ea189a98ef8f2a3c5521482968"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, void *val)</td></tr>
<tr class="memdesc:ae61b28ea189a98ef8f2a3c5521482968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new entry with given key and value to hash table h.  <a href="#ae61b28ea189a98ef8f2a3c5521482968">More...</a><br/></td></tr>
<tr class="separator:ae61b28ea189a98ef8f2a3c5521482968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d87b1b825c302473f2d7c5a3b88475"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#af1d87b1b825c302473f2d7c5a3b88475">hash_table_delete</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key)</td></tr>
<tr class="memdesc:af1d87b1b825c302473f2d7c5a3b88475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an entry with given key and associated value to hash table h.  <a href="#af1d87b1b825c302473f2d7c5a3b88475">More...</a><br/></td></tr>
<tr class="separator:af1d87b1b825c302473f2d7c5a3b88475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ab1f5eb2f1b4689645d1e1c19dc887"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aa2ab1f5eb2f1b4689645d1e1c19dc887">hash_table_delete_bkey</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, size_t len)</td></tr>
<tr class="memdesc:aa2ab1f5eb2f1b4689645d1e1c19dc887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like hash_table_delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#aa2ab1f5eb2f1b4689645d1e1c19dc887">More...</a><br/></td></tr>
<tr class="separator:aa2ab1f5eb2f1b4689645d1e1c19dc887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab374d21e25009d397642e3465308c7"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acab374d21e25009d397642e3465308c7">hash_table_empty</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h)</td></tr>
<tr class="memdesc:acab374d21e25009d397642e3465308c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all entries from a hash_table.  <a href="#acab374d21e25009d397642e3465308c7">More...</a><br/></td></tr>
<tr class="separator:acab374d21e25009d397642e3465308c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5752fadefe2662adb2c141f1511062"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, size_t len, void *val)</td></tr>
<tr class="memdesc:a6f5752fadefe2662adb2c141f1511062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like hash_table_enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#a6f5752fadefe2662adb2c141f1511062">More...</a><br/></td></tr>
<tr class="separator:a6f5752fadefe2662adb2c141f1511062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273237d63833e5625c830f421d9463de"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, size_t len, void *val)</td></tr>
<tr class="memdesc:a273237d63833e5625c830f421d9463de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like hash_table_replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#a273237d63833e5625c830f421d9463de">More...</a><br/></td></tr>
<tr class="separator:a273237d63833e5625c830f421d9463de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e5ed410eb96f514b00fdce770fbd7"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a9a1e5ed410eb96f514b00fdce770fbd7">hash_table_lookup</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, void **val)</td></tr>
<tr class="memdesc:a9a1e5ed410eb96f514b00fdce770fbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a key in a hash table and optionally return the associated value.  <a href="#a9a1e5ed410eb96f514b00fdce770fbd7">More...</a><br/></td></tr>
<tr class="separator:a9a1e5ed410eb96f514b00fdce770fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf27e8e7e336faf6653649937c42ed8"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acaf27e8e7e336faf6653649937c42ed8">hash_table_lookup_int32</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, int32 *val)</td></tr>
<tr class="memdesc:acaf27e8e7e336faf6653649937c42ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a 32-bit integer value in a hash table.  <a href="#acaf27e8e7e336faf6653649937c42ed8">More...</a><br/></td></tr>
<tr class="separator:acaf27e8e7e336faf6653649937c42ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f5b3924c0e3a50f94c86bb5fd078e8"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a91f5b3924c0e3a50f94c86bb5fd078e8">hash_table_lookup_bkey</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, size_t len, void **val)</td></tr>
<tr class="memdesc:a91f5b3924c0e3a50f94c86bb5fd078e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string.  <a href="#a91f5b3924c0e3a50f94c86bb5fd078e8">More...</a><br/></td></tr>
<tr class="separator:a91f5b3924c0e3a50f94c86bb5fd078e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc530eda0b105745cf3a47cc3c1148e4"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#acc530eda0b105745cf3a47cc3c1148e4">hash_table_lookup_bkey_int32</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, const char *key, size_t len, int32 *val)</td></tr>
<tr class="memdesc:acc530eda0b105745cf3a47cc3c1148e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a 32-bit integer value in a hash table.  <a href="#acc530eda0b105745cf3a47cc3c1148e4">More...</a><br/></td></tr>
<tr class="separator:acc530eda0b105745cf3a47cc3c1148e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6e6373d3c371d57861a9a875edb207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6e6373d3c371d57861a9a875edb207"></a>
SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#aae6e6373d3c371d57861a9a875edb207">hash_table_iter</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h)</td></tr>
<tr class="memdesc:aae6e6373d3c371d57861a9a875edb207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start iterating over key-value pairs in a hash table. <br/></td></tr>
<tr class="separator:aae6e6373d3c371d57861a9a875edb207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad023321efab26a30bd6d855fbdbe08a3"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#ad023321efab26a30bd6d855fbdbe08a3">hash_table_iter_next</a> (<a class="el" href="structhash__iter__s.html">hash_iter_t</a> *itor)</td></tr>
<tr class="memdesc:ad023321efab26a30bd6d855fbdbe08a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next key-value pair in iteration.  <a href="#ad023321efab26a30bd6d855fbdbe08a3">More...</a><br/></td></tr>
<tr class="separator:ad023321efab26a30bd6d855fbdbe08a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa43b228d7dc24f5221d281debeb025"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa43b228d7dc24f5221d281debeb025"></a>
SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a7aa43b228d7dc24f5221d281debeb025">hash_table_iter_free</a> (<a class="el" href="structhash__iter__s.html">hash_iter_t</a> *itor)</td></tr>
<tr class="memdesc:a7aa43b228d7dc24f5221d281debeb025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an unfinished iterator. <br/></td></tr>
<tr class="separator:a7aa43b228d7dc24f5221d281debeb025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f59389f05d8871003da4692a9c2acc"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a61f59389f05d8871003da4692a9c2acc">hash_table_tolist</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, int32 *count)</td></tr>
<tr class="memdesc:a61f59389f05d8871003da4692a9c2acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a glist of valid hash_entry_t pointers from the given hash table.  <a href="#a61f59389f05d8871003da4692a9c2acc">More...</a><br/></td></tr>
<tr class="separator:a61f59389f05d8871003da4692a9c2acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2721f6b601c80ceeeae570589fd12e38"><td class="memItemLeft" align="right" valign="top">SPHINXBASE_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash__table_8h.html#a2721f6b601c80ceeeae570589fd12e38">hash_table_display</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *h, int32 showkey)</td></tr>
<tr class="memdesc:a2721f6b601c80ceeeae570589fd12e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a hash-with-chaining representation on the screen.  <a href="#a2721f6b601c80ceeeae570589fd12e38">More...</a><br/></td></tr>
<tr class="separator:a2721f6b601c80ceeeae570589fd12e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hash table implementation. </p>
<p>This hash tables are intended for associating a pointer/integer "value" with a char string "key", (e.g., an ID with a word string). Subsequently, one can retrieve the value by providing the string key. (The reverse functionality&ndash;obtaining the string given the value&ndash;is not provided with the hash table module.) </p>

<p>Definition in file <a class="el" href="hash__table_8h_source.html">hash_table.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ada31c1e0bcf359a7ca934748f4680333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_bkey_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a6f5752fadefe2662adb2c141f1511062">hash_table_enter_bkey</a>((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enter a 32-bit integer value in a hash table. </p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

<p>Definition at line <a class="el" href="hash__table_8h_source.html#l00315">315</a> of file <a class="el" href="hash__table_8h_source.html">hash_table.h</a>.</p>

</div>
</div>
<a class="anchor" id="a393c56322e54607a48e6bc61169d92bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_enter_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412">hash_table_enter</a>((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a 32-bit integer value to a hash table. </p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

<p>Definition at line <a class="el" href="hash__table_8h_source.html#l00228">228</a> of file <a class="el" href="hash__table_8h_source.html">hash_table.h</a>.</p>

<p>Referenced by <a class="el" href="ngram__model_8c_source.html#l00299">ngram_model_casefold()</a>, and <a class="el" href="ngram__model__set_8c_source.html#l00637">ngram_model_set_map_words()</a>.</p>

</div>
</div>
<a class="anchor" id="ace238b264acacb8e6cb0de14f1035f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_bkey_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#a273237d63833e5625c830f421d9463de">hash_table_replace_bkey</a>((h),(k),(l),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a 32-bit integer value in a hash table. </p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

<p>Definition at line <a class="el" href="hash__table_8h_source.html#l00338">338</a> of file <a class="el" href="hash__table_8h_source.html">hash_table.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4286033aa772a9d1f3aa219469324f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_table_replace_int32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">h, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">k, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((int32)(long)<a class="el" href="hash__table_8h.html#ae61b28ea189a98ef8f2a3c5521482968">hash_table_replace</a>((h),(k),(void *)(long)(v)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a 32-bit integer value in a hash table. </p>
<p>This macro is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>

<p>Definition at line <a class="el" href="hash__table_8h_source.html#l00257">257</a> of file <a class="el" href="hash__table_8h_source.html">hash_table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af70e2b25a853da786ffd99731a5fac5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structhash__entry__s.html">hash_entry_s</a>  <a class="el" href="hash__table_8h.html#af70e2b25a853da786ffd99731a5fac5a">hash_entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A note by ARCHAN at 20050510: Technically what we use is so-called "hash table with buckets" which is very nice way to deal with external hashing. </p>
<p>There are definitely better ways to do internal hashing (i.e. when everything is stored in the memory.) In Sphinx 3, this is a reasonable practice because hash table is only used in lookup in initialization or in lookups which is not critical for speed. Another note by ARCHAN at 20050703: To use this data structure properly, it is very important to realize that the users are required to handle memory allocation of the C-style keys. The hash table will not make a copy of the memory allocated for any of the C-style key. It will not allocate memory for it. It will not delete memory for it. As a result, the following code sniplet will cause memory leak.</p>
<p>while (1){ str=(char*)<a class="el" href="ckd__alloc_8h.html#aa00ef21903bc4f8a972488417adc8d2e" title="Macros to simplify the use of above functions. ">ckd_calloc(str_length,sizeof(char*))</a> if(hash_enter(ht,str,id)!=id){ printf("fail to add key str %s with val id %d\n",str,id)} } A note by dhuggins on 20061010: Changed this to use void * instead of int32 as the value type, so that arbitrary objects can be inserted into a hash table (in a way that won't crash on 64-bit machines ;) The hash table structures. Each hash table is identified by a <a class="el" href="structhash__table__t.html">hash_table_t</a> structure. hash_table_t.table is pre-allocated for a user-controlled max size, and is initially empty. As new entries are created (using hash_enter()), the empty entries get filled. If multiple keys hash to the same entry, new entries are allocated and linked together in a linear list. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af1d87b1b825c302473f2d7c5a3b88475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an entry with given key and associated value to hash table h. </p>
<p>Return the value associated with the key (NULL if it did not exist) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which a key will be deleted </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00530">530</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ab1f5eb2f1b4689645d1e1c19dc887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_delete_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like hash_table_delete, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. </p>
<p>So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which a key will be deleted </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00568">568</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a2721f6b601c80ceeeae570589fd12e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_display </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>showkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display a hash-with-chaining representation on the screen. </p>
<p>Currently, it will only works for situation where hash_enter was used to enter the keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Hash table to display </td></tr>
    <tr><td class="paramname">showkey</td><td>In: Show the string or not, Use 0 if hash_enter_bkey was used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00581">581</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8h_source.html#l00153">hash_entry_s::len</a>, <a class="el" href="hash__table_8h_source.html#l00156">hash_entry_s::next</a>, <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>, and <a class="el" href="hash__table_8h_source.html#l00155">hash_entry_s::val</a>.</p>

</div>
</div>
<a class="anchor" id="acab374d21e25009d397642e3465308c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all entries from a hash_table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00490">490</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>, <a class="el" href="hash__table_8h_source.html#l00164">hash_table_t::inuse</a>, <a class="el" href="hash__table_8h_source.html#l00156">hash_entry_s::next</a>, and <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>.</p>

<p>Referenced by <a class="el" href="ngram__model__set_8c_source.html#l00637">ngram_model_set_map_words()</a>.</p>

</div>
</div>
<a class="anchor" id="aebfe63c3869c271b125a8413ee384412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to add a new entry with given key and associated value to hash table h. </p>
<p>If key doesn't already exist in hash table, the addition is successful, and the return value is val. But if key already exists, return its existing associated value. (The hash table is unchanged; it is up to the caller to resolve the conflict.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00508">508</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l00552">cmd_ln_parse_r()</a>, and <a class="el" href="huff__code_8c_source.html#l00309">huff_code_read()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f5752fadefe2662adb2c141f1511062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_enter_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like hash_table_enter, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. </p>
<p>So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00542">542</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>.</p>

<p>Referenced by <a class="el" href="huff__code_8c_source.html#l00309">huff_code_read()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a588c22946f8cc16328973035ed19e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void hash_table_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the specified hash table; the caller is responsible for freeing the key strings pointed to by the table entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table to free </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00695">695</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>, <a class="el" href="hash__table_8h_source.html#l00156">hash_entry_s::next</a>, and <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l01039">cmd_ln_free_r()</a>, <a class="el" href="cmd__ln_8c_source.html#l00552">cmd_ln_parse_r()</a>, <a class="el" href="huff__code_8c_source.html#l00450">huff_code_free()</a>, <a class="el" href="jsgf_8c_source.html#l00129">jsgf_grammar_free()</a>, <a class="el" href="ngram__model_8c_source.html#l00299">ngram_model_casefold()</a>, <a class="el" href="ngram__model_8c_source.html#l00254">ngram_model_free()</a>, <a class="el" href="ngram__model_8c_source.html#l01220">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c_source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div>
<a class="anchor" id="ad023321efab26a30bd6d855fbdbe08a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structhash__iter__s.html">hash_iter_t</a>* hash_table_iter_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__iter__s.html">hash_iter_t</a> *&#160;</td>
          <td class="paramname"><em>itor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next key-value pair in iteration. </p>
<p>This function automatically frees the iterator object upon reaching the final entry.</p>
<dl class="section return"><dt>Returns</dt><dd>the next entry in the hash table, or NULL if done. </dd></dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00663">663</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8h_source.html#l00170">hash_iter_s::ent</a>, <a class="el" href="hash__table_8c_source.html#l00689">hash_table_iter_free()</a>, <a class="el" href="hash__table_8h_source.html#l00169">hash_iter_s::ht</a>, <a class="el" href="hash__table_8h_source.html#l00171">hash_iter_s::idx</a>, <a class="el" href="hash__table_8h_source.html#l00156">hash_entry_s::next</a>, and <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c_source.html#l00653">hash_table_iter()</a>, and <a class="el" href="jsgf_8c_source.html#l00129">jsgf_grammar_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a1e5ed410eb96f514b00fdce770fbd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a key in a hash table and optionally return the associated value. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if key found in hash table, else -1. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated string whose value is sought </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00309">309</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8h_source.html#l00155">hash_entry_s::val</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l00941">cmd_ln_access_r()</a>, <a class="el" href="cmd__ln_8c_source.html#l00932">cmd_ln_exists_r()</a>, <a class="el" href="cmd__ln_8c_source.html#l00552">cmd_ln_parse_r()</a>, <a class="el" href="hash__table_8c_source.html#l00329">hash_table_lookup_int32()</a>, <a class="el" href="huff__code_8c_source.html#l00516">huff_code_encode_str()</a>, <a class="el" href="jsgf_8c_source.html#l00497">jsgf_get_rule()</a>, and <a class="el" href="ngram__model__set_8c_source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div>
<a class="anchor" id="a91f5b3924c0e3a50f94c86bb5fd078e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like hash_lookup, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. </p>
<p>So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00344">344</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>, and <a class="el" href="hash__table_8h_source.html#l00155">hash_entry_s::val</a>.</p>

<p>Referenced by <a class="el" href="hash__table_8c_source.html#l00365">hash_table_lookup_bkey_int32()</a>, and <a class="el" href="huff__code_8c_source.html#l00500">huff_code_encode_int()</a>.</p>

</div>
</div>
<a class="anchor" id="acc530eda0b105745cf3a47cc3c1148e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_bkey_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a 32-bit integer value in a hash table. </p>
<p>This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00365">365</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c_source.html#l00344">hash_table_lookup_bkey()</a>.</p>

</div>
</div>
<a class="anchor" id="acaf27e8e7e336faf6653649937c42ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT int32 hash_table_lookup_int32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a 32-bit integer value in a hash table. </p>
<p>This function is the clean way to do this and avoid compiler warnings on 64-bit platforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table being searched </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated string whose value is sought </td></tr>
    <tr><td class="paramname">val</td><td>Out: *val = value associated with key. If this is NULL, no value will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00329">329</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="hash__table_8c_source.html#l00309">hash_table_lookup()</a>.</p>

<p>Referenced by <a class="el" href="ngram__model_8c_source.html#l00664">ngram_unknown_wid()</a>, and <a class="el" href="ngram__model_8c_source.html#l00791">ngram_wid()</a>.</p>

</div>
</div>
<a class="anchor" id="a56d93e8c03e066b77377ac6eab50cfae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structhash__table__t.html">hash_table_t</a>* hash_table_new </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>casearg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new hash table for a given expected size. </p>
<dl class="section note"><dt>Note</dt><dd>Case sensitivity of hash keys applies to 7-bit ASCII characters only, and is not locale-dependent.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>handle to allocated hash table. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>In: Expected number of entries in the table </td></tr>
    <tr><td class="paramname">casearg</td><td>In: Whether case insensitive for key comparisons. When 1, case is insentitive, 0, case is sensitive. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00158">158</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8h_source.html#l00248">ckd_calloc</a>, <a class="el" href="hash__table_8h_source.html#l00165">hash_table_t::nocase</a>, and <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l00552">cmd_ln_parse_r()</a>, <a class="el" href="huff__code_8c_source.html#l00309">huff_code_read()</a>, <a class="el" href="jsgf_8c_source.html#l00083">jsgf_grammar_new()</a>, <a class="el" href="ngram__model_8c_source.html#l00299">ngram_model_casefold()</a>, <a class="el" href="ngram__model_8c_source.html#l01220">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c_source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div>
<a class="anchor" id="ae61b28ea189a98ef8f2a3c5521482968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new entry with given key and value to hash table h. </p>
<p>If the key already exists, its value is replaced with the given value, and the previous value is returned, otherwise val is returned.</p>
<p>A very important but subtle point: The key pointer in the hash table is <b>replaced</b> with the pointer passed to this function. In general you should always pass a pointer to <a class="el" href="hash__table_8h.html#aebfe63c3869c271b125a8413ee384412" title="Try to add a new entry with given key and associated value to hash table h. ">hash_table_enter()</a> whose lifetime matches or exceeds that of the hash table. In some rare cases it is convenient to initially enter a value with a short-lived key, then later replace that with a long-lived one. This behaviour allows this to happen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: C-style NULL-terminated key string for the new entry </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00519">519</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l00552">cmd_ln_parse_r()</a>.</p>

</div>
</div>
<a class="anchor" id="a273237d63833e5625c830f421d9463de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT void* hash_table_replace_bkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like hash_table_replace, but with an explicitly specified key length, instead of a NULL-terminated, C-style key string. </p>
<p>So the key string is a binary key (or bkey). Hash tables containing such keys should be created with the HASH_CASE_YES option. Otherwise, the results are unpredictable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Handle of hash table in which to create entry </td></tr>
    <tr><td class="paramname">key</td><td>In: Key buffer </td></tr>
    <tr><td class="paramname">len</td><td>In: Length of above key buffer </td></tr>
    <tr><td class="paramname">val</td><td>In: Value to be associated with above key </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00555">555</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="ckd__alloc_8c_source.html#l00244">ckd_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a61f59389f05d8871003da4692a9c2acc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPHINXBASE_EXPORT <a class="el" href="structgnode__s.html">glist_t</a> hash_table_tolist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a glist of valid hash_entry_t pointers from the given hash table. </p>
<p>Return the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>In: Hash table from which list is to be generated </td></tr>
    <tr><td class="paramname">count</td><td>Out: Number of entries in the list. If this is NULL, no count will be returned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="hash__table_8c_source.html#l00623">623</a> of file <a class="el" href="hash__table_8c_source.html">hash_table.c</a>.</p>

<p>References <a class="el" href="glist_8c_source.html#l00074">glist_add_ptr()</a>, <a class="el" href="hash__table_8h_source.html#l00156">hash_entry_s::next</a>, and <a class="el" href="hash__table_8h_source.html#l00161">hash_table_t::size</a>.</p>

<p>Referenced by <a class="el" href="cmd__ln_8c_source.html#l01039">cmd_ln_free_r()</a>, <a class="el" href="ngram__model_8c_source.html#l01220">ngram_model_read_classdef()</a>, and <a class="el" href="ngram__model__set_8c_source.html#l00182">ngram_model_set_read()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_e3d154c296a8e9be2797a4f81e9375b2.html">sphinxbase</a></li><li class="navelem"><a class="el" href="hash__table_8h.html">hash_table.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
