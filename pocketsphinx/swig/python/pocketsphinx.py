# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
This documentation was automatically generated using original comments in
Doxygen format. As some C types and data structures cannot be directly mapped
into Python types, some non-trivial type conversion could have place.
Basically a type is replaced with another one that has the closest match, and
sometimes one argument of generated function comprises several arguments of the
original function (usually two). Apparently Doxygen comments do not mention
this fact, so here is a list of all known conversions so far:

  FILE * -> file
  const int16 *SDATA, size_t NSAMP -> str

Also functions having error code as the return value and returning effective
value in one of its arguments are transformed so that the effective value is
returned in a regular fashion and run-time exception is being thrown in case of
negative error code.
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pocketsphinx', [dirname(__file__)])
        except ImportError:
            import _pocketsphinx
            return _pocketsphinx
        if fp is not None:
            try:
                _mod = imp.load_module('_pocketsphinx', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pocketsphinx = swig_import_helper()
    del swig_import_helper
else:
    import _pocketsphinx
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


import sphinxbase
class Hypothesis(_object):
    """Proxy of C Hypothesis struct"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hypothesis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Hypothesis, name)
    __repr__ = _swig_repr
    __swig_setmethods__["hypstr"] = _pocketsphinx.Hypothesis_hypstr_set
    __swig_getmethods__["hypstr"] = _pocketsphinx.Hypothesis_hypstr_get
    if _newclass:hypstr = _swig_property(_pocketsphinx.Hypothesis_hypstr_get, _pocketsphinx.Hypothesis_hypstr_set)
    __swig_setmethods__["uttid"] = _pocketsphinx.Hypothesis_uttid_set
    __swig_getmethods__["uttid"] = _pocketsphinx.Hypothesis_uttid_get
    if _newclass:uttid = _swig_property(_pocketsphinx.Hypothesis_uttid_get, _pocketsphinx.Hypothesis_uttid_set)
    __swig_setmethods__["best_score"] = _pocketsphinx.Hypothesis_best_score_set
    __swig_getmethods__["best_score"] = _pocketsphinx.Hypothesis_best_score_get
    if _newclass:best_score = _swig_property(_pocketsphinx.Hypothesis_best_score_get, _pocketsphinx.Hypothesis_best_score_set)
    def __init__(self, *args): 
        """__init__(Hypothesis self, char const * hypstr, char const * uttid, int best_score) -> Hypothesis"""
        this = _pocketsphinx.new_Hypothesis(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pocketsphinx.delete_Hypothesis
    __del__ = lambda self : None;
Hypothesis_swigregister = _pocketsphinx.Hypothesis_swigregister
Hypothesis_swigregister(Hypothesis)

class Segment(_object):
    """Proxy of C Segment struct"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Segment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Segment, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ptr"] = _pocketsphinx.Segment_ptr_set
    __swig_getmethods__["ptr"] = _pocketsphinx.Segment_ptr_get
    if _newclass:ptr = _swig_property(_pocketsphinx.Segment_ptr_get, _pocketsphinx.Segment_ptr_set)
    __swig_setmethods__["word"] = _pocketsphinx.Segment_word_set
    __swig_getmethods__["word"] = _pocketsphinx.Segment_word_get
    if _newclass:word = _swig_property(_pocketsphinx.Segment_word_get, _pocketsphinx.Segment_word_set)
    __swig_setmethods__["ascr"] = _pocketsphinx.Segment_ascr_set
    __swig_getmethods__["ascr"] = _pocketsphinx.Segment_ascr_get
    if _newclass:ascr = _swig_property(_pocketsphinx.Segment_ascr_get, _pocketsphinx.Segment_ascr_set)
    __swig_setmethods__["lscr"] = _pocketsphinx.Segment_lscr_set
    __swig_getmethods__["lscr"] = _pocketsphinx.Segment_lscr_get
    if _newclass:lscr = _swig_property(_pocketsphinx.Segment_lscr_get, _pocketsphinx.Segment_lscr_set)
    __swig_setmethods__["lback"] = _pocketsphinx.Segment_lback_set
    __swig_getmethods__["lback"] = _pocketsphinx.Segment_lback_get
    if _newclass:lback = _swig_property(_pocketsphinx.Segment_lback_get, _pocketsphinx.Segment_lback_set)
    __swig_setmethods__["start_frame"] = _pocketsphinx.Segment_start_frame_set
    __swig_getmethods__["start_frame"] = _pocketsphinx.Segment_start_frame_get
    if _newclass:start_frame = _swig_property(_pocketsphinx.Segment_start_frame_get, _pocketsphinx.Segment_start_frame_set)
    __swig_setmethods__["end_frame"] = _pocketsphinx.Segment_end_frame_set
    __swig_getmethods__["end_frame"] = _pocketsphinx.Segment_end_frame_get
    if _newclass:end_frame = _swig_property(_pocketsphinx.Segment_end_frame_get, _pocketsphinx.Segment_end_frame_set)
    def __init__(self, *args): 
        """__init__(Segment self, ps_seg_t * ptr) -> Segment"""
        this = _pocketsphinx.new_Segment(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pocketsphinx.delete_Segment
    __del__ = lambda self : None;
    def __iter__(self):
        return self

    def next(self):
        """
        next(Segment self) -> Segment

        Get the next segment in a word segmentation.

        Parameters:
        -----------

        seg:  Segment iterator.

        Updated iterator with the next segment. NULL at end of utterance (the
        iterator will be freed in this case). 
        """
        return _pocketsphinx.Segment_next(self)

Segment_swigregister = _pocketsphinx.Segment_swigregister
Segment_swigregister(Segment)

class NBest(_object):
    """Proxy of C NBest struct"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NBest, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NBest, name)
    __repr__ = _swig_repr
    __swig_setmethods__["ptr"] = _pocketsphinx.NBest_ptr_set
    __swig_getmethods__["ptr"] = _pocketsphinx.NBest_ptr_get
    if _newclass:ptr = _swig_property(_pocketsphinx.NBest_ptr_get, _pocketsphinx.NBest_ptr_set)
    def __init__(self, *args): 
        """__init__(NBest self, ps_nbest_t * ptr) -> NBest"""
        this = _pocketsphinx.new_NBest(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pocketsphinx.delete_NBest
    __del__ = lambda self : None;
    def __iter__(self):
        return self

    def next(self):
        """
        next(NBest self) -> NBest

        Move an N-best list iterator forward.

        Parameters:
        -----------

        nbest:  N-best iterator.

        Updated N-best iterator, or NULL if no more hypotheses are available
        (iterator is freed ni this case). 
        """
        return _pocketsphinx.NBest_next(self)

    def hyp(self):
        """
        hyp(NBest self) -> Hypothesis

        Get the hypothesis string from an N-best list iterator.

        Parameters:
        -----------

        nbest:  N-best iterator.

        out_score:  Output: Path score for this hypothesis.

        String containing next best hypothesis. 
        """
        return _pocketsphinx.NBest_hyp(self)

    def seg(self):
        """
        seg(NBest self) -> Segment

        Get the word segmentation from an N-best list iterator.

        Parameters:
        -----------

        nbest:  N-best iterator.

        out_score:  Output: Path score for this hypothesis.

        Iterator over the next best hypothesis. 
        """
        return _pocketsphinx.NBest_seg(self)

NBest_swigregister = _pocketsphinx.NBest_swigregister
NBest_swigregister(NBest)

class Decoder(_object):
    """Proxy of C Decoder struct"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Decoder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Decoder, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Decoder self) -> Decoder
        __init__(Decoder self, Config config) -> Decoder
        """
        this = _pocketsphinx.new_Decoder(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pocketsphinx.delete_Decoder
    __del__ = lambda self : None;
    def reinit(self, *args):
        """
        reinit(Decoder self, Config config)

        Reinitialize the decoder with updated configuration.

        This function allows you to switch the acoustic model, dictionary, or
        other configuration without creating an entirely new decoding object.

        The decoder retains ownership of the pointer config, so you must not
        attempt to free it manually. If you wish to reuse it elsewhere, call
        cmd_ln_retain() on it.

        Parameters:
        -----------

        ps:  Decoder.

        config:  An optional new configuration to use. If this is NULL, the
        previous configuration will be reloaded, with any changes applied.

        0 for success, <0 for failure. 
        """
        return _pocketsphinx.Decoder_reinit(self, *args)

    def load_dict(self, *args):
        """
        load_dict(Decoder self, char const * fdict, char const * ffilter, char const * format)

        Reload the pronunciation dictionary from a file.

        This function replaces the current pronunciation dictionary with the
        one stored in dictfile. This also causes the active search module(s)
        to be reinitialized, in the same manner as calling ps_add_word() with
        update=TRUE.

        Parameters:
        -----------

        dictfile:  Path to dictionary file to load.

        fdictfile:  Path to filler dictionary to load, or NULL to keep the
        existing filler dictionary.

        format:  Format of the dictionary file, or NULL to determine
        automatically (currently unused,should be NULL) 
        """
        return _pocketsphinx.Decoder_load_dict(self, *args)

    def save_dict(self, *args):
        """
        save_dict(Decoder self, char const * dictfile, char const * format)

        Dump the current pronunciation dictionary to a file.

        This function dumps the current pronunciation dictionary to a tex

        Parameters:
        -----------

        dictfile:  Path to file where dictionary will be written.

        format:  Format of the dictionary file, or NULL for the default (text)
        format (currently unused, should be NULL) 
        """
        return _pocketsphinx.Decoder_save_dict(self, *args)

    def add_word(self, *args):
        """
        add_word(Decoder self, char const * word, char const * phones, int update)

        Add a word to the pronunciation dictionary.

        This function adds a word to the pronunciation dictionary and the
        current language model (but, obviously, not to the current FSG if FSG
        mode is enabled). If the word is already present in one or the other,
        it does whatever is necessary to ensure that the word can be
        recognized.

        Parameters:
        -----------

        word:  Word string to add.

        phones:  Whitespace-separated list of phoneme strings describing
        pronunciation of word.

        update:  If TRUE, update the search module (whichever one is currently
        active) to recognize the newly added word. If adding multiple words,
        it is more efficient to pass FALSE here in all but the last word.

        The internal ID (>= 0) of the newly added word, or <0 on failure. 
        """
        return _pocketsphinx.Decoder_add_word(self, *args)

    def get_lattice(self):
        """
        get_lattice(Decoder self) -> Lattice

        Get word lattice.

        There isn't much you can do with this so far, a public API will appear
        in the future.

        Parameters:
        -----------

        ps:  Decoder.

        Word lattice object containing all hypotheses so far. NULL if no
        hypotheses are available. This pointer is owned by the decoder and you
        should not attempt to free it manually. It is only valid until the
        next utterance, unless you use ps_lattice_retain() to retain it. 
        """
        return _pocketsphinx.Decoder_get_lattice(self)

    def get_config(self):
        """
        get_config(Decoder self) -> Config

        Get the configuration object for this decoder.

        The configuration object for this decoder. The decoder retains
        ownership of this pointer, so you should not attempt to free it
        manually. Use cmd_ln_retain() if you wish to reuse it elsewhere. 
        """
        return _pocketsphinx.Decoder_get_config(self)

    def default_config():
        """default_config() -> Config"""
        return _pocketsphinx.Decoder_default_config()

    if _newclass:default_config = staticmethod(default_config)
    __swig_getmethods__["default_config"] = lambda x: default_config
    def file_config(*args):
        """file_config(char const * path) -> Config"""
        return _pocketsphinx.Decoder_file_config(*args)

    if _newclass:file_config = staticmethod(file_config)
    __swig_getmethods__["file_config"] = lambda x: file_config
    def start_utt(self, *args):
        """
        start_utt(Decoder self, char const * uttid)

        Start utterance processing.

        This function should be called before any utterance data is passed to
        the decoder. It marks the start of a new utterance and reinitializes
        internal data structures.

        Parameters:
        -----------

        ps:  Decoder to be started.

        uttid:  String uniquely identifying this utterance. If NULL, one will
        be created.

        0 for success, <0 on error. 
        """
        return _pocketsphinx.Decoder_start_utt(self, *args)

    def get_uttid(self):
        """
        get_uttid(Decoder self) -> char const *

        Get current utterance ID.

        Parameters:
        -----------

        ps:  Decoder to query.

        Read-only string of the current utterance ID. This is valid only until
        the beginning of the next utterance. 
        """
        return _pocketsphinx.Decoder_get_uttid(self)

    def end_utt(self):
        """
        end_utt(Decoder self)

        End utterance processing.

        Parameters:
        -----------

        ps:  Decoder.

        0 for success, <0 on error 
        """
        return _pocketsphinx.Decoder_end_utt(self)

    def process_raw(self, *args):
        """
        process_raw(Decoder self, void const * SDATA, bool no_search, bool full_utt) -> int

        Decode raw audio data.

        Parameters:
        -----------

        ps:  Decoder.

        no_search:  If non-zero, perform feature extraction but don't do any
        recognition yet. This may be necessary if your processor has trouble
        doing recognition in real-time.

        full_utt:  If non-zero, this block of data is a full utterance worth
        of data. This may allow the recognizer to produce more accurate
        results.

        Number of frames of data searched, or <0 for error. 
        """
        return _pocketsphinx.Decoder_process_raw(self, *args)

    def decode_raw(self, *args):
        """
        decode_raw(Decoder self, FILE * fin) -> int

        Decode a raw audio stream.

        No headers are recognized in this files. The configuration parameters
        -samprate and -input_endian are used to determine the sampling rate
        and endianness of the stream, respectively. Audio is always assumed to
        be 16-bit signed PCM.

        Parameters:
        -----------

        ps:  Decoder.

        rawfh:  Previously opened file stream.

        uttid:  Utterance ID (or NULL to generate automatically).

        maxsamps:  Maximum number of samples to read from rawfh, or -1 to read
        until end- of-file.

        Number of samples of audio. 
        """
        return _pocketsphinx.Decoder_decode_raw(self, *args)

    def hyp(self):
        """hyp(Decoder self) -> Hypothesis"""
        return _pocketsphinx.Decoder_hyp(self)

    def nbest(self):
        """
        nbest(Decoder self) -> NBest

        Get an iterator over the best hypotheses, optionally within a selected
        region of the utterance.

        Iterator is empty now, it must be advanced with ps_nbest_next first.
        The function may also return a NULL which means that there is no
        hypothesis available for this utterance.

        Parameters:
        -----------

        ps:  Decoder.

        sf:  Start frame for N-best search (0 for whole utterance)

        ef:  End frame for N-best search (-1 for whole utterance)

        ctx1:  First word of trigram context (NULL for whole utterance)

        ctx2:  First word of trigram context (NULL for whole utterance)

        Iterator over N-best hypotheses or NULL if no hypothesis is available

        """
        return _pocketsphinx.Decoder_nbest(self)

    def seg(self):
        """seg(Decoder self) -> Segment"""
        return _pocketsphinx.Decoder_seg(self)

    def get_fe(self):
        """
        get_fe(Decoder self) -> FrontEnd

        Get the feature extraction object for this decoder.

        The feature extraction object for this decoder. The decoder retains
        ownership of this pointer, so you should not attempt to free it
        manually. Use fe_retain() if you wish to reuse it elsewhere. 
        """
        return _pocketsphinx.Decoder_get_fe(self)

    def get_feat(self):
        """
        get_feat(Decoder self) -> Feature

        Get the dynamic feature computation object for this decoder.

        The dynamic feature computation object for this decoder. The decoder
        retains ownership of this pointer, so you should not attempt to free
        it manually. Use feat_retain() if you wish to reuse it elsewhere. 
        """
        return _pocketsphinx.Decoder_get_feat(self)

    def get_vad_state(self):
        """
        get_vad_state(Decoder self) -> bool

        Checks if the last feed audio buffer contained speech.

        Parameters:
        -----------

        ps:  Decoder.

        1 if last buffer contained speech, 0 - otherwise 
        """
        return _pocketsphinx.Decoder_get_vad_state(self)

    def get_fsg(self, *args):
        """
        get_fsg(Decoder self, char const * name) -> FsgModel

        Get the finite-state grammar set object for this decoder.

        If FSG decoding is not enabled, this returns NULL. Call
        ps_update_fsgset() to enable it.

        The current FSG set object for this decoder, or NULL if none is
        available. 
        """
        return _pocketsphinx.Decoder_get_fsg(self, *args)

    def set_fsg(self, *args):
        """
        set_fsg(Decoder self, char const * name, FsgModel fsg)

        Adds new search based on finite state grammar.

        Associates FSG search with the provided name. The search can be
        activated using ps_set_search().

        See:   ps_set_search 
        """
        return _pocketsphinx.Decoder_set_fsg(self, *args)

    def set_jsgf_file(self, *args):
        """
        set_jsgf_file(Decoder self, char const * name, char const * path)

        Adds new search using JSGF model.

        Convenient method to load JSGF model and create a search.

        See:   ps_set_fsg 
        """
        return _pocketsphinx.Decoder_set_jsgf_file(self, *args)

    def get_kws(self, *args):
        """
        get_kws(Decoder self, char const * name) -> char const *

        Get the current Key phrase to spot.

        If KWS is not enabled, this returns NULL. Call ps_update_kws() to
        enable it.

        The current keyphrase to spot 
        """
        return _pocketsphinx.Decoder_get_kws(self, *args)

    def set_kws(self, *args):
        """
        set_kws(Decoder self, char const * name, char const * keyfile)

        Adds keywords from a file to spotting.

        Associates KWS search with the provided name. The search can be
        activated using ps_set_search().

        See:   ps_set_search 
        """
        return _pocketsphinx.Decoder_set_kws(self, *args)

    def set_keyphrase(self, *args):
        """
        set_keyphrase(Decoder self, char const * name, char const * keyphrase)

        Adds new keyword to spot.

        Associates KWS search with the provided name. The search can be
        activated using ps_set_search().

        See:   ps_set_search 
        """
        return _pocketsphinx.Decoder_set_keyphrase(self, *args)

    def get_lm(self, *args):
        """
        get_lm(Decoder self, char const * name) -> NGramModel

        Get the language model set object for this decoder.

        If N-Gram decoding is not enabled, this will return NULL. You will
        need to enable it using ps_update_lmset().

        The language model set object for this decoder. The decoder retains
        ownership of this pointer, so you should not attempt to free it
        manually. Use ngram_model_retain() if you wish to reuse it elsewhere.

        """
        return _pocketsphinx.Decoder_get_lm(self, *args)

    def set_lm(self, *args):
        """
        set_lm(Decoder self, char const * name, NGramModel lm)

        Adds new search based on N-gram language model.

        Associates N-gram search with the provided name. The search can be
        activated using ps_set_search().

        See:   ps_set_search. 
        """
        return _pocketsphinx.Decoder_set_lm(self, *args)

    def set_lm_file(self, *args):
        """
        set_lm_file(Decoder self, char const * name, char const * path)

        Adds new search based on N-gram language model.

        Convenient method to load N-gram model and create a search.

        See:   ps_set_lm 
        """
        return _pocketsphinx.Decoder_set_lm_file(self, *args)

    def get_logmath(self):
        """
        get_logmath(Decoder self) -> LogMath *

        Get the log-math computation object for this decoder.

        The log-math object for this decoder. The decoder retains ownership of
        this pointer, so you should not attempt to free it manually. Use
        logmath_retain() if you wish to reuse it elsewhere. 
        """
        return _pocketsphinx.Decoder_get_logmath(self)

    def set_search(self, *args):
        """
        set_search(Decoder self, char const * search_name)

        Actives search with the provided name.

        Activates search with the provided name. The search must be added
        before using either ps_set_fsg(), ps_set_lm() or ps_set_kws().

        0 on success, 1 on failure 
        """
        return _pocketsphinx.Decoder_set_search(self, *args)

    def get_search(self):
        """
        get_search(Decoder self) -> char const *

        Returns name of curent search in decoder.

        See:   ps_set_search 
        """
        return _pocketsphinx.Decoder_get_search(self)

    def n_frames(self):
        """n_frames(Decoder self) -> int"""
        return _pocketsphinx.Decoder_n_frames(self)

Decoder_swigregister = _pocketsphinx.Decoder_swigregister
Decoder_swigregister(Decoder)

def Decoder_default_config():
  """Decoder_default_config() -> Config"""
  return _pocketsphinx.Decoder_default_config()

def Decoder_file_config(*args):
  """Decoder_file_config(char const * path) -> Config"""
  return _pocketsphinx.Decoder_file_config(*args)

class Lattice(_object):
    """Proxy of C Lattice struct"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Lattice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Lattice, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(Lattice self, char const * path) -> Lattice
        __init__(Lattice self, Decoder decoder, char * path) -> Lattice
        """
        this = _pocketsphinx.new_Lattice(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pocketsphinx.delete_Lattice
    __del__ = lambda self : None;
    def write(self, *args):
        """
        write(Lattice self, char const * path)

        Write a lattice to disk.

        0 for success, <0 on failure. 
        """
        return _pocketsphinx.Lattice_write(self, *args)

    def write_htk(self, *args):
        """
        write_htk(Lattice self, char const * path)

        Write a lattice to disk in HTK format.

        0 for success, <0 on failure. 
        """
        return _pocketsphinx.Lattice_write_htk(self, *args)

Lattice_swigregister = _pocketsphinx.Lattice_swigregister
Lattice_swigregister(Lattice)

SEARCH_FSG = _pocketsphinx.SEARCH_FSG
SEARCH_NGRAM = _pocketsphinx.SEARCH_NGRAM
# This file is compatible with both classic and new-style classes.


